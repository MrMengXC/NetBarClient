// Generated by ProtoGen, Version=2.4.1.555, Culture=neutral, PublicKeyToken=17b3b1f090c3ea48.  DO NOT EDIT!
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.ProtocolBuffers;
using pbc = global::Google.ProtocolBuffers.Collections;
using pbd = global::Google.ProtocolBuffers.Descriptors;
using scg = global::System.Collections.Generic;
[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public static partial class Common {

  #region Extension registration
  public static void RegisterAllExtensions(pb::ExtensionRegistry registry) {
  }
  #endregion
  #region Static variables
  internal static pbd::MessageDescriptor internal__static_CSUploadPicture__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CSUploadPicture, global::CSUploadPicture.Builder> internal__static_CSUploadPicture__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_SCUploadPicture__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::SCUploadPicture, global::SCUploadPicture.Builder> internal__static_SCUploadPicture__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CSDownloadPicture__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CSDownloadPicture, global::CSDownloadPicture.Builder> internal__static_CSDownloadPicture__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_SCDownloadPicture__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::SCDownloadPicture, global::SCDownloadPicture.Builder> internal__static_SCDownloadPicture__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CSHeart__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CSHeart, global::CSHeart.Builder> internal__static_CSHeart__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_SCHeart__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::SCHeart, global::SCHeart.Builder> internal__static_SCHeart__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CSKick__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CSKick, global::CSKick.Builder> internal__static_CSKick__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_SCKick__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::SCKick, global::SCKick.Builder> internal__static_SCKick__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CSReconnect__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CSReconnect, global::CSReconnect.Builder> internal__static_CSReconnect__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_SCReconnect__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::SCReconnect, global::SCReconnect.Builder> internal__static_SCReconnect__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CSPreCharge__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CSPreCharge, global::CSPreCharge.Builder> internal__static_CSPreCharge__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_SCPreCharge__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::SCPreCharge, global::SCPreCharge.Builder> internal__static_SCPreCharge__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_SCToCharge__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::SCToCharge, global::SCToCharge.Builder> internal__static_SCToCharge__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CSPreBuy__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CSPreBuy, global::CSPreBuy.Builder> internal__static_CSPreBuy__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_SCPreBuy__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::SCPreBuy, global::SCPreBuy.Builder> internal__static_SCPreBuy__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_SCToBuy__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::SCToBuy, global::SCToBuy.Builder> internal__static_SCToBuy__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_SCMessage__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::SCMessage, global::SCMessage.Builder> internal__static_SCMessage__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CSCommand__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CSCommand, global::CSCommand.Builder> internal__static_CSCommand__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CSGoodsFind__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CSGoodsFind, global::CSGoodsFind.Builder> internal__static_CSGoodsFind__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_SCGoodsFind__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::SCGoodsFind, global::SCGoodsFind.Builder> internal__static_SCGoodsFind__FieldAccessorTable;
  #endregion
  #region Descriptor
  public static pbd::FileDescriptor Descriptor {
    get { return descriptor; }
  }
  private static pbd::FileDescriptor descriptor;
  
  static Common() {
    byte[] descriptorData = global::System.Convert.FromBase64String(
        string.Concat(
          "CgxDb21tb24ucHJvdG8aEEJhc2VTdHJ1Y3QucHJvdG8iEQoPQ1NVcGxvYWRQ", 
          "aWN0dXJlIhEKD1NDVXBsb2FkUGljdHVyZSITChFDU0Rvd25sb2FkUGljdHVy", 
          "ZSITChFTQ0Rvd25sb2FkUGljdHVyZSIJCgdDU0hlYXJ0IgkKB1NDSGVhcnQi", 
          "CAoGQ1NLaWNrIggKBlNDS2ljayJECgtDU1JlY29ubmVjdBIOCgZ1c2VySWQY", 
          "ASACKAkSEAoIcGFzc3dvcmQYAiACKAkSEwoLZGV2aWNlVG9rZW4YAyABKAki", 
          "LgoLU0NSZWNvbm5lY3QSEQoJc2Vzc2lvbklkGAEgAigFEgwKBGd1aWQYAiAB", 
          "KAUiUwoLQ1NQcmVDaGFyZ2USEgoKY2FyZG51bWJlchgBIAIoCRIOCgZhbW91", 
          "bnQYAiACKAUSDwoHcGF5bW9kZRgDIAIoBRIPCgdvZmZpY2FsGAQgAigFIh0K", 
          "C1NDUHJlQ2hhcmdlEg4KBnFyY29kZRgBIAIoCSJxCgpTQ1RvQ2hhcmdlEgwK", 
          "BG5hbWUYASACKAkSEgoKY2FyZG51bWJlchgCIAIoCRINCgVyaWdodBgDIAIo", 
          "CRIQCghyZWNoYXJnZRgEIAIoBRIPCgdiYWxhbmNlGAUgAigFEg8KB2ludGVn", 
          "YWwYBiACKAUiQQoIQ1NQcmVCdXkSEgoKY2FyZG51bWJlchgBIAIoCRIPCgdn", 
          "b29kc2lkGAIgAigFEhAKCGdvb2RzbnVtGAMgAigFIhoKCFNDUHJlQnV5Eg4K", 
          "BnFyY29kZRgBIAIoCSKEAQoHU0NUb0J1eRIMCgRuYW1lGAEgAigJEhIKCmNh", 
          "cmRudW1iZXIYAiACKAkSDQoFcmlnaHQYAyACKAkSEQoJdXNlZG1vbmV5GAQg", 
          "AigFEhMKC3VzZWRpbnRlZ2FsGAUgAigFEg8KB2JhbGFuY2UYBiACKAUSDwoH", 
          "aW50ZWdhbBgHIAIoBSIoCglTQ01lc3NhZ2USCwoDY21kGAEgAigFEg4KBnBh", 
          "cmFtcxgCIAMoCSIoCglDU0NvbW1hbmQSCwoDY21kGAEgAigFEg4KBnBhcmFt", 
          "cxgCIAMoCSJMCgtDU0dvb2RzRmluZBIZCgRwYWdlGAEgAigLMgsuU3RydWN0", 
          "UGFnZRIQCghjYXRlZ29yeRgCIAEoBRIQCghrZXl3b3JkcxgEIAEoCSIqCgtT", 
          "Q0dvb2RzRmluZBIbCgVnb29kcxgBIAMoCzIMLlN0cnVjdEdvb2RzQi8KHWNv", 
        "bS5za3lzb2Z0LmNvcmUuYXV0by5tZXNzYWdlQg5Db21tb25Qcm90b2NvbA=="));
    pbd::FileDescriptor.InternalDescriptorAssigner assigner = delegate(pbd::FileDescriptor root) {
      descriptor = root;
      internal__static_CSUploadPicture__Descriptor = Descriptor.MessageTypes[0];
      internal__static_CSUploadPicture__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CSUploadPicture, global::CSUploadPicture.Builder>(internal__static_CSUploadPicture__Descriptor,
              new string[] { });
      internal__static_SCUploadPicture__Descriptor = Descriptor.MessageTypes[1];
      internal__static_SCUploadPicture__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::SCUploadPicture, global::SCUploadPicture.Builder>(internal__static_SCUploadPicture__Descriptor,
              new string[] { });
      internal__static_CSDownloadPicture__Descriptor = Descriptor.MessageTypes[2];
      internal__static_CSDownloadPicture__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CSDownloadPicture, global::CSDownloadPicture.Builder>(internal__static_CSDownloadPicture__Descriptor,
              new string[] { });
      internal__static_SCDownloadPicture__Descriptor = Descriptor.MessageTypes[3];
      internal__static_SCDownloadPicture__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::SCDownloadPicture, global::SCDownloadPicture.Builder>(internal__static_SCDownloadPicture__Descriptor,
              new string[] { });
      internal__static_CSHeart__Descriptor = Descriptor.MessageTypes[4];
      internal__static_CSHeart__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CSHeart, global::CSHeart.Builder>(internal__static_CSHeart__Descriptor,
              new string[] { });
      internal__static_SCHeart__Descriptor = Descriptor.MessageTypes[5];
      internal__static_SCHeart__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::SCHeart, global::SCHeart.Builder>(internal__static_SCHeart__Descriptor,
              new string[] { });
      internal__static_CSKick__Descriptor = Descriptor.MessageTypes[6];
      internal__static_CSKick__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CSKick, global::CSKick.Builder>(internal__static_CSKick__Descriptor,
              new string[] { });
      internal__static_SCKick__Descriptor = Descriptor.MessageTypes[7];
      internal__static_SCKick__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::SCKick, global::SCKick.Builder>(internal__static_SCKick__Descriptor,
              new string[] { });
      internal__static_CSReconnect__Descriptor = Descriptor.MessageTypes[8];
      internal__static_CSReconnect__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CSReconnect, global::CSReconnect.Builder>(internal__static_CSReconnect__Descriptor,
              new string[] { "UserId", "Password", "DeviceToken", });
      internal__static_SCReconnect__Descriptor = Descriptor.MessageTypes[9];
      internal__static_SCReconnect__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::SCReconnect, global::SCReconnect.Builder>(internal__static_SCReconnect__Descriptor,
              new string[] { "SessionId", "Guid", });
      internal__static_CSPreCharge__Descriptor = Descriptor.MessageTypes[10];
      internal__static_CSPreCharge__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CSPreCharge, global::CSPreCharge.Builder>(internal__static_CSPreCharge__Descriptor,
              new string[] { "Cardnumber", "Amount", "Paymode", "Offical", });
      internal__static_SCPreCharge__Descriptor = Descriptor.MessageTypes[11];
      internal__static_SCPreCharge__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::SCPreCharge, global::SCPreCharge.Builder>(internal__static_SCPreCharge__Descriptor,
              new string[] { "Qrcode", });
      internal__static_SCToCharge__Descriptor = Descriptor.MessageTypes[12];
      internal__static_SCToCharge__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::SCToCharge, global::SCToCharge.Builder>(internal__static_SCToCharge__Descriptor,
              new string[] { "Name", "Cardnumber", "Right", "Recharge", "Balance", "Integal", });
      internal__static_CSPreBuy__Descriptor = Descriptor.MessageTypes[13];
      internal__static_CSPreBuy__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CSPreBuy, global::CSPreBuy.Builder>(internal__static_CSPreBuy__Descriptor,
              new string[] { "Cardnumber", "Goodsid", "Goodsnum", });
      internal__static_SCPreBuy__Descriptor = Descriptor.MessageTypes[14];
      internal__static_SCPreBuy__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::SCPreBuy, global::SCPreBuy.Builder>(internal__static_SCPreBuy__Descriptor,
              new string[] { "Qrcode", });
      internal__static_SCToBuy__Descriptor = Descriptor.MessageTypes[15];
      internal__static_SCToBuy__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::SCToBuy, global::SCToBuy.Builder>(internal__static_SCToBuy__Descriptor,
              new string[] { "Name", "Cardnumber", "Right", "Usedmoney", "Usedintegal", "Balance", "Integal", });
      internal__static_SCMessage__Descriptor = Descriptor.MessageTypes[16];
      internal__static_SCMessage__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::SCMessage, global::SCMessage.Builder>(internal__static_SCMessage__Descriptor,
              new string[] { "Cmd", "Params", });
      internal__static_CSCommand__Descriptor = Descriptor.MessageTypes[17];
      internal__static_CSCommand__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CSCommand, global::CSCommand.Builder>(internal__static_CSCommand__Descriptor,
              new string[] { "Cmd", "Params", });
      internal__static_CSGoodsFind__Descriptor = Descriptor.MessageTypes[18];
      internal__static_CSGoodsFind__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CSGoodsFind, global::CSGoodsFind.Builder>(internal__static_CSGoodsFind__Descriptor,
              new string[] { "Page", "Category", "Keywords", });
      internal__static_SCGoodsFind__Descriptor = Descriptor.MessageTypes[19];
      internal__static_SCGoodsFind__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::SCGoodsFind, global::SCGoodsFind.Builder>(internal__static_SCGoodsFind__Descriptor,
              new string[] { "Goods", });
      return null;
    };
    pbd::FileDescriptor.InternalBuildGeneratedFileFrom(descriptorData,
        new pbd::FileDescriptor[] {
        global::BaseStruct.Descriptor, 
        }, assigner);
  }
  #endregion
  
}
#region Messages
[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CSUploadPicture : pb::GeneratedMessage<CSUploadPicture, CSUploadPicture.Builder> {
  private CSUploadPicture() { }
  private static readonly CSUploadPicture defaultInstance = new CSUploadPicture().MakeReadOnly();
  private static readonly string[] _cSUploadPictureFieldNames = new string[] {  };
  private static readonly uint[] _cSUploadPictureFieldTags = new uint[] {  };
  public static CSUploadPicture DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override CSUploadPicture DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override CSUploadPicture ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Common.internal__static_CSUploadPicture__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<CSUploadPicture, CSUploadPicture.Builder> InternalFieldAccessors {
    get { return global::Common.internal__static_CSUploadPicture__FieldAccessorTable; }
  }
  
  public override bool IsInitialized {
    get {
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    CalcSerializedSize();
    string[] field_names = _cSUploadPictureFieldNames;
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      return CalcSerializedSize();
    }
  }
  
  private int CalcSerializedSize() {
    int size = memoizedSerializedSize;
    if (size != -1) return size;
    
    size = 0;
    size += UnknownFields.SerializedSize;
    memoizedSerializedSize = size;
    return size;
  }
  public static CSUploadPicture ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSUploadPicture ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSUploadPicture ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSUploadPicture ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSUploadPicture ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSUploadPicture ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static CSUploadPicture ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static CSUploadPicture ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static CSUploadPicture ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSUploadPicture ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private CSUploadPicture MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(CSUploadPicture prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<CSUploadPicture, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(CSUploadPicture cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private CSUploadPicture result;
    
    private CSUploadPicture PrepareBuilder() {
      if (resultIsReadOnly) {
        CSUploadPicture original = result;
        result = new CSUploadPicture();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override CSUploadPicture MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::CSUploadPicture.Descriptor; }
    }
    
    public override CSUploadPicture DefaultInstanceForType {
      get { return global::CSUploadPicture.DefaultInstance; }
    }
    
    public override CSUploadPicture BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is CSUploadPicture) {
        return MergeFrom((CSUploadPicture) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(CSUploadPicture other) {
      if (other == global::CSUploadPicture.DefaultInstance) return this;
      PrepareBuilder();
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_cSUploadPictureFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _cSUploadPictureFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
  }
  static CSUploadPicture() {
    object.ReferenceEquals(global::Common.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class SCUploadPicture : pb::GeneratedMessage<SCUploadPicture, SCUploadPicture.Builder> {
  private SCUploadPicture() { }
  private static readonly SCUploadPicture defaultInstance = new SCUploadPicture().MakeReadOnly();
  private static readonly string[] _sCUploadPictureFieldNames = new string[] {  };
  private static readonly uint[] _sCUploadPictureFieldTags = new uint[] {  };
  public static SCUploadPicture DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override SCUploadPicture DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override SCUploadPicture ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Common.internal__static_SCUploadPicture__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<SCUploadPicture, SCUploadPicture.Builder> InternalFieldAccessors {
    get { return global::Common.internal__static_SCUploadPicture__FieldAccessorTable; }
  }
  
  public override bool IsInitialized {
    get {
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    CalcSerializedSize();
    string[] field_names = _sCUploadPictureFieldNames;
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      return CalcSerializedSize();
    }
  }
  
  private int CalcSerializedSize() {
    int size = memoizedSerializedSize;
    if (size != -1) return size;
    
    size = 0;
    size += UnknownFields.SerializedSize;
    memoizedSerializedSize = size;
    return size;
  }
  public static SCUploadPicture ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static SCUploadPicture ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static SCUploadPicture ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static SCUploadPicture ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static SCUploadPicture ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static SCUploadPicture ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static SCUploadPicture ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static SCUploadPicture ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static SCUploadPicture ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static SCUploadPicture ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private SCUploadPicture MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(SCUploadPicture prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<SCUploadPicture, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(SCUploadPicture cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private SCUploadPicture result;
    
    private SCUploadPicture PrepareBuilder() {
      if (resultIsReadOnly) {
        SCUploadPicture original = result;
        result = new SCUploadPicture();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override SCUploadPicture MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::SCUploadPicture.Descriptor; }
    }
    
    public override SCUploadPicture DefaultInstanceForType {
      get { return global::SCUploadPicture.DefaultInstance; }
    }
    
    public override SCUploadPicture BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is SCUploadPicture) {
        return MergeFrom((SCUploadPicture) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(SCUploadPicture other) {
      if (other == global::SCUploadPicture.DefaultInstance) return this;
      PrepareBuilder();
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_sCUploadPictureFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _sCUploadPictureFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
  }
  static SCUploadPicture() {
    object.ReferenceEquals(global::Common.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CSDownloadPicture : pb::GeneratedMessage<CSDownloadPicture, CSDownloadPicture.Builder> {
  private CSDownloadPicture() { }
  private static readonly CSDownloadPicture defaultInstance = new CSDownloadPicture().MakeReadOnly();
  private static readonly string[] _cSDownloadPictureFieldNames = new string[] {  };
  private static readonly uint[] _cSDownloadPictureFieldTags = new uint[] {  };
  public static CSDownloadPicture DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override CSDownloadPicture DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override CSDownloadPicture ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Common.internal__static_CSDownloadPicture__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<CSDownloadPicture, CSDownloadPicture.Builder> InternalFieldAccessors {
    get { return global::Common.internal__static_CSDownloadPicture__FieldAccessorTable; }
  }
  
  public override bool IsInitialized {
    get {
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    CalcSerializedSize();
    string[] field_names = _cSDownloadPictureFieldNames;
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      return CalcSerializedSize();
    }
  }
  
  private int CalcSerializedSize() {
    int size = memoizedSerializedSize;
    if (size != -1) return size;
    
    size = 0;
    size += UnknownFields.SerializedSize;
    memoizedSerializedSize = size;
    return size;
  }
  public static CSDownloadPicture ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSDownloadPicture ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSDownloadPicture ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSDownloadPicture ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSDownloadPicture ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSDownloadPicture ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static CSDownloadPicture ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static CSDownloadPicture ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static CSDownloadPicture ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSDownloadPicture ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private CSDownloadPicture MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(CSDownloadPicture prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<CSDownloadPicture, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(CSDownloadPicture cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private CSDownloadPicture result;
    
    private CSDownloadPicture PrepareBuilder() {
      if (resultIsReadOnly) {
        CSDownloadPicture original = result;
        result = new CSDownloadPicture();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override CSDownloadPicture MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::CSDownloadPicture.Descriptor; }
    }
    
    public override CSDownloadPicture DefaultInstanceForType {
      get { return global::CSDownloadPicture.DefaultInstance; }
    }
    
    public override CSDownloadPicture BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is CSDownloadPicture) {
        return MergeFrom((CSDownloadPicture) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(CSDownloadPicture other) {
      if (other == global::CSDownloadPicture.DefaultInstance) return this;
      PrepareBuilder();
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_cSDownloadPictureFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _cSDownloadPictureFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
  }
  static CSDownloadPicture() {
    object.ReferenceEquals(global::Common.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class SCDownloadPicture : pb::GeneratedMessage<SCDownloadPicture, SCDownloadPicture.Builder> {
  private SCDownloadPicture() { }
  private static readonly SCDownloadPicture defaultInstance = new SCDownloadPicture().MakeReadOnly();
  private static readonly string[] _sCDownloadPictureFieldNames = new string[] {  };
  private static readonly uint[] _sCDownloadPictureFieldTags = new uint[] {  };
  public static SCDownloadPicture DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override SCDownloadPicture DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override SCDownloadPicture ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Common.internal__static_SCDownloadPicture__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<SCDownloadPicture, SCDownloadPicture.Builder> InternalFieldAccessors {
    get { return global::Common.internal__static_SCDownloadPicture__FieldAccessorTable; }
  }
  
  public override bool IsInitialized {
    get {
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    CalcSerializedSize();
    string[] field_names = _sCDownloadPictureFieldNames;
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      return CalcSerializedSize();
    }
  }
  
  private int CalcSerializedSize() {
    int size = memoizedSerializedSize;
    if (size != -1) return size;
    
    size = 0;
    size += UnknownFields.SerializedSize;
    memoizedSerializedSize = size;
    return size;
  }
  public static SCDownloadPicture ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static SCDownloadPicture ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static SCDownloadPicture ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static SCDownloadPicture ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static SCDownloadPicture ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static SCDownloadPicture ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static SCDownloadPicture ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static SCDownloadPicture ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static SCDownloadPicture ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static SCDownloadPicture ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private SCDownloadPicture MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(SCDownloadPicture prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<SCDownloadPicture, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(SCDownloadPicture cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private SCDownloadPicture result;
    
    private SCDownloadPicture PrepareBuilder() {
      if (resultIsReadOnly) {
        SCDownloadPicture original = result;
        result = new SCDownloadPicture();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override SCDownloadPicture MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::SCDownloadPicture.Descriptor; }
    }
    
    public override SCDownloadPicture DefaultInstanceForType {
      get { return global::SCDownloadPicture.DefaultInstance; }
    }
    
    public override SCDownloadPicture BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is SCDownloadPicture) {
        return MergeFrom((SCDownloadPicture) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(SCDownloadPicture other) {
      if (other == global::SCDownloadPicture.DefaultInstance) return this;
      PrepareBuilder();
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_sCDownloadPictureFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _sCDownloadPictureFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
  }
  static SCDownloadPicture() {
    object.ReferenceEquals(global::Common.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CSHeart : pb::GeneratedMessage<CSHeart, CSHeart.Builder> {
  private CSHeart() { }
  private static readonly CSHeart defaultInstance = new CSHeart().MakeReadOnly();
  private static readonly string[] _cSHeartFieldNames = new string[] {  };
  private static readonly uint[] _cSHeartFieldTags = new uint[] {  };
  public static CSHeart DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override CSHeart DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override CSHeart ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Common.internal__static_CSHeart__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<CSHeart, CSHeart.Builder> InternalFieldAccessors {
    get { return global::Common.internal__static_CSHeart__FieldAccessorTable; }
  }
  
  public override bool IsInitialized {
    get {
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    CalcSerializedSize();
    string[] field_names = _cSHeartFieldNames;
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      return CalcSerializedSize();
    }
  }
  
  private int CalcSerializedSize() {
    int size = memoizedSerializedSize;
    if (size != -1) return size;
    
    size = 0;
    size += UnknownFields.SerializedSize;
    memoizedSerializedSize = size;
    return size;
  }
  public static CSHeart ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSHeart ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSHeart ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSHeart ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSHeart ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSHeart ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static CSHeart ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static CSHeart ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static CSHeart ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSHeart ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private CSHeart MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(CSHeart prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<CSHeart, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(CSHeart cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private CSHeart result;
    
    private CSHeart PrepareBuilder() {
      if (resultIsReadOnly) {
        CSHeart original = result;
        result = new CSHeart();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override CSHeart MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::CSHeart.Descriptor; }
    }
    
    public override CSHeart DefaultInstanceForType {
      get { return global::CSHeart.DefaultInstance; }
    }
    
    public override CSHeart BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is CSHeart) {
        return MergeFrom((CSHeart) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(CSHeart other) {
      if (other == global::CSHeart.DefaultInstance) return this;
      PrepareBuilder();
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_cSHeartFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _cSHeartFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
  }
  static CSHeart() {
    object.ReferenceEquals(global::Common.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class SCHeart : pb::GeneratedMessage<SCHeart, SCHeart.Builder> {
  private SCHeart() { }
  private static readonly SCHeart defaultInstance = new SCHeart().MakeReadOnly();
  private static readonly string[] _sCHeartFieldNames = new string[] {  };
  private static readonly uint[] _sCHeartFieldTags = new uint[] {  };
  public static SCHeart DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override SCHeart DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override SCHeart ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Common.internal__static_SCHeart__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<SCHeart, SCHeart.Builder> InternalFieldAccessors {
    get { return global::Common.internal__static_SCHeart__FieldAccessorTable; }
  }
  
  public override bool IsInitialized {
    get {
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    CalcSerializedSize();
    string[] field_names = _sCHeartFieldNames;
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      return CalcSerializedSize();
    }
  }
  
  private int CalcSerializedSize() {
    int size = memoizedSerializedSize;
    if (size != -1) return size;
    
    size = 0;
    size += UnknownFields.SerializedSize;
    memoizedSerializedSize = size;
    return size;
  }
  public static SCHeart ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static SCHeart ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static SCHeart ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static SCHeart ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static SCHeart ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static SCHeart ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static SCHeart ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static SCHeart ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static SCHeart ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static SCHeart ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private SCHeart MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(SCHeart prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<SCHeart, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(SCHeart cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private SCHeart result;
    
    private SCHeart PrepareBuilder() {
      if (resultIsReadOnly) {
        SCHeart original = result;
        result = new SCHeart();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override SCHeart MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::SCHeart.Descriptor; }
    }
    
    public override SCHeart DefaultInstanceForType {
      get { return global::SCHeart.DefaultInstance; }
    }
    
    public override SCHeart BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is SCHeart) {
        return MergeFrom((SCHeart) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(SCHeart other) {
      if (other == global::SCHeart.DefaultInstance) return this;
      PrepareBuilder();
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_sCHeartFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _sCHeartFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
  }
  static SCHeart() {
    object.ReferenceEquals(global::Common.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CSKick : pb::GeneratedMessage<CSKick, CSKick.Builder> {
  private CSKick() { }
  private static readonly CSKick defaultInstance = new CSKick().MakeReadOnly();
  private static readonly string[] _cSKickFieldNames = new string[] {  };
  private static readonly uint[] _cSKickFieldTags = new uint[] {  };
  public static CSKick DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override CSKick DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override CSKick ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Common.internal__static_CSKick__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<CSKick, CSKick.Builder> InternalFieldAccessors {
    get { return global::Common.internal__static_CSKick__FieldAccessorTable; }
  }
  
  public override bool IsInitialized {
    get {
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    CalcSerializedSize();
    string[] field_names = _cSKickFieldNames;
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      return CalcSerializedSize();
    }
  }
  
  private int CalcSerializedSize() {
    int size = memoizedSerializedSize;
    if (size != -1) return size;
    
    size = 0;
    size += UnknownFields.SerializedSize;
    memoizedSerializedSize = size;
    return size;
  }
  public static CSKick ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSKick ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSKick ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSKick ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSKick ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSKick ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static CSKick ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static CSKick ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static CSKick ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSKick ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private CSKick MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(CSKick prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<CSKick, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(CSKick cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private CSKick result;
    
    private CSKick PrepareBuilder() {
      if (resultIsReadOnly) {
        CSKick original = result;
        result = new CSKick();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override CSKick MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::CSKick.Descriptor; }
    }
    
    public override CSKick DefaultInstanceForType {
      get { return global::CSKick.DefaultInstance; }
    }
    
    public override CSKick BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is CSKick) {
        return MergeFrom((CSKick) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(CSKick other) {
      if (other == global::CSKick.DefaultInstance) return this;
      PrepareBuilder();
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_cSKickFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _cSKickFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
  }
  static CSKick() {
    object.ReferenceEquals(global::Common.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class SCKick : pb::GeneratedMessage<SCKick, SCKick.Builder> {
  private SCKick() { }
  private static readonly SCKick defaultInstance = new SCKick().MakeReadOnly();
  private static readonly string[] _sCKickFieldNames = new string[] {  };
  private static readonly uint[] _sCKickFieldTags = new uint[] {  };
  public static SCKick DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override SCKick DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override SCKick ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Common.internal__static_SCKick__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<SCKick, SCKick.Builder> InternalFieldAccessors {
    get { return global::Common.internal__static_SCKick__FieldAccessorTable; }
  }
  
  public override bool IsInitialized {
    get {
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    CalcSerializedSize();
    string[] field_names = _sCKickFieldNames;
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      return CalcSerializedSize();
    }
  }
  
  private int CalcSerializedSize() {
    int size = memoizedSerializedSize;
    if (size != -1) return size;
    
    size = 0;
    size += UnknownFields.SerializedSize;
    memoizedSerializedSize = size;
    return size;
  }
  public static SCKick ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static SCKick ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static SCKick ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static SCKick ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static SCKick ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static SCKick ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static SCKick ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static SCKick ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static SCKick ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static SCKick ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private SCKick MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(SCKick prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<SCKick, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(SCKick cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private SCKick result;
    
    private SCKick PrepareBuilder() {
      if (resultIsReadOnly) {
        SCKick original = result;
        result = new SCKick();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override SCKick MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::SCKick.Descriptor; }
    }
    
    public override SCKick DefaultInstanceForType {
      get { return global::SCKick.DefaultInstance; }
    }
    
    public override SCKick BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is SCKick) {
        return MergeFrom((SCKick) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(SCKick other) {
      if (other == global::SCKick.DefaultInstance) return this;
      PrepareBuilder();
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_sCKickFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _sCKickFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
  }
  static SCKick() {
    object.ReferenceEquals(global::Common.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CSReconnect : pb::GeneratedMessage<CSReconnect, CSReconnect.Builder> {
  private CSReconnect() { }
  private static readonly CSReconnect defaultInstance = new CSReconnect().MakeReadOnly();
  private static readonly string[] _cSReconnectFieldNames = new string[] { "deviceToken", "password", "userId" };
  private static readonly uint[] _cSReconnectFieldTags = new uint[] { 26, 18, 10 };
  public static CSReconnect DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override CSReconnect DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override CSReconnect ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Common.internal__static_CSReconnect__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<CSReconnect, CSReconnect.Builder> InternalFieldAccessors {
    get { return global::Common.internal__static_CSReconnect__FieldAccessorTable; }
  }
  
  public const int UserIdFieldNumber = 1;
  private bool hasUserId;
  private string userId_ = "";
  public bool HasUserId {
    get { return hasUserId; }
  }
  public string UserId {
    get { return userId_; }
  }
  
  public const int PasswordFieldNumber = 2;
  private bool hasPassword;
  private string password_ = "";
  public bool HasPassword {
    get { return hasPassword; }
  }
  public string Password {
    get { return password_; }
  }
  
  public const int DeviceTokenFieldNumber = 3;
  private bool hasDeviceToken;
  private string deviceToken_ = "";
  public bool HasDeviceToken {
    get { return hasDeviceToken; }
  }
  public string DeviceToken {
    get { return deviceToken_; }
  }
  
  public override bool IsInitialized {
    get {
      if (!hasUserId) return false;
      if (!hasPassword) return false;
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    CalcSerializedSize();
    string[] field_names = _cSReconnectFieldNames;
    if (hasUserId) {
      output.WriteString(1, field_names[2], UserId);
    }
    if (hasPassword) {
      output.WriteString(2, field_names[1], Password);
    }
    if (hasDeviceToken) {
      output.WriteString(3, field_names[0], DeviceToken);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      return CalcSerializedSize();
    }
  }
  
  private int CalcSerializedSize() {
    int size = memoizedSerializedSize;
    if (size != -1) return size;
    
    size = 0;
    if (hasUserId) {
      size += pb::CodedOutputStream.ComputeStringSize(1, UserId);
    }
    if (hasPassword) {
      size += pb::CodedOutputStream.ComputeStringSize(2, Password);
    }
    if (hasDeviceToken) {
      size += pb::CodedOutputStream.ComputeStringSize(3, DeviceToken);
    }
    size += UnknownFields.SerializedSize;
    memoizedSerializedSize = size;
    return size;
  }
  public static CSReconnect ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSReconnect ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSReconnect ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSReconnect ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSReconnect ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSReconnect ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static CSReconnect ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static CSReconnect ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static CSReconnect ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSReconnect ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private CSReconnect MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(CSReconnect prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<CSReconnect, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(CSReconnect cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private CSReconnect result;
    
    private CSReconnect PrepareBuilder() {
      if (resultIsReadOnly) {
        CSReconnect original = result;
        result = new CSReconnect();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override CSReconnect MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::CSReconnect.Descriptor; }
    }
    
    public override CSReconnect DefaultInstanceForType {
      get { return global::CSReconnect.DefaultInstance; }
    }
    
    public override CSReconnect BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is CSReconnect) {
        return MergeFrom((CSReconnect) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(CSReconnect other) {
      if (other == global::CSReconnect.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasUserId) {
        UserId = other.UserId;
      }
      if (other.HasPassword) {
        Password = other.Password;
      }
      if (other.HasDeviceToken) {
        DeviceToken = other.DeviceToken;
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_cSReconnectFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _cSReconnectFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 10: {
            result.hasUserId = input.ReadString(ref result.userId_);
            break;
          }
          case 18: {
            result.hasPassword = input.ReadString(ref result.password_);
            break;
          }
          case 26: {
            result.hasDeviceToken = input.ReadString(ref result.deviceToken_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasUserId {
      get { return result.hasUserId; }
    }
    public string UserId {
      get { return result.UserId; }
      set { SetUserId(value); }
    }
    public Builder SetUserId(string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasUserId = true;
      result.userId_ = value;
      return this;
    }
    public Builder ClearUserId() {
      PrepareBuilder();
      result.hasUserId = false;
      result.userId_ = "";
      return this;
    }
    
    public bool HasPassword {
      get { return result.hasPassword; }
    }
    public string Password {
      get { return result.Password; }
      set { SetPassword(value); }
    }
    public Builder SetPassword(string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasPassword = true;
      result.password_ = value;
      return this;
    }
    public Builder ClearPassword() {
      PrepareBuilder();
      result.hasPassword = false;
      result.password_ = "";
      return this;
    }
    
    public bool HasDeviceToken {
      get { return result.hasDeviceToken; }
    }
    public string DeviceToken {
      get { return result.DeviceToken; }
      set { SetDeviceToken(value); }
    }
    public Builder SetDeviceToken(string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasDeviceToken = true;
      result.deviceToken_ = value;
      return this;
    }
    public Builder ClearDeviceToken() {
      PrepareBuilder();
      result.hasDeviceToken = false;
      result.deviceToken_ = "";
      return this;
    }
  }
  static CSReconnect() {
    object.ReferenceEquals(global::Common.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class SCReconnect : pb::GeneratedMessage<SCReconnect, SCReconnect.Builder> {
  private SCReconnect() { }
  private static readonly SCReconnect defaultInstance = new SCReconnect().MakeReadOnly();
  private static readonly string[] _sCReconnectFieldNames = new string[] { "guid", "sessionId" };
  private static readonly uint[] _sCReconnectFieldTags = new uint[] { 16, 8 };
  public static SCReconnect DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override SCReconnect DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override SCReconnect ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Common.internal__static_SCReconnect__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<SCReconnect, SCReconnect.Builder> InternalFieldAccessors {
    get { return global::Common.internal__static_SCReconnect__FieldAccessorTable; }
  }
  
  public const int SessionIdFieldNumber = 1;
  private bool hasSessionId;
  private int sessionId_;
  public bool HasSessionId {
    get { return hasSessionId; }
  }
  public int SessionId {
    get { return sessionId_; }
  }
  
  public const int GuidFieldNumber = 2;
  private bool hasGuid;
  private int guid_;
  public bool HasGuid {
    get { return hasGuid; }
  }
  public int Guid {
    get { return guid_; }
  }
  
  public override bool IsInitialized {
    get {
      if (!hasSessionId) return false;
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    CalcSerializedSize();
    string[] field_names = _sCReconnectFieldNames;
    if (hasSessionId) {
      output.WriteInt32(1, field_names[1], SessionId);
    }
    if (hasGuid) {
      output.WriteInt32(2, field_names[0], Guid);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      return CalcSerializedSize();
    }
  }
  
  private int CalcSerializedSize() {
    int size = memoizedSerializedSize;
    if (size != -1) return size;
    
    size = 0;
    if (hasSessionId) {
      size += pb::CodedOutputStream.ComputeInt32Size(1, SessionId);
    }
    if (hasGuid) {
      size += pb::CodedOutputStream.ComputeInt32Size(2, Guid);
    }
    size += UnknownFields.SerializedSize;
    memoizedSerializedSize = size;
    return size;
  }
  public static SCReconnect ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static SCReconnect ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static SCReconnect ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static SCReconnect ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static SCReconnect ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static SCReconnect ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static SCReconnect ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static SCReconnect ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static SCReconnect ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static SCReconnect ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private SCReconnect MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(SCReconnect prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<SCReconnect, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(SCReconnect cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private SCReconnect result;
    
    private SCReconnect PrepareBuilder() {
      if (resultIsReadOnly) {
        SCReconnect original = result;
        result = new SCReconnect();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override SCReconnect MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::SCReconnect.Descriptor; }
    }
    
    public override SCReconnect DefaultInstanceForType {
      get { return global::SCReconnect.DefaultInstance; }
    }
    
    public override SCReconnect BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is SCReconnect) {
        return MergeFrom((SCReconnect) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(SCReconnect other) {
      if (other == global::SCReconnect.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasSessionId) {
        SessionId = other.SessionId;
      }
      if (other.HasGuid) {
        Guid = other.Guid;
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_sCReconnectFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _sCReconnectFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 8: {
            result.hasSessionId = input.ReadInt32(ref result.sessionId_);
            break;
          }
          case 16: {
            result.hasGuid = input.ReadInt32(ref result.guid_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasSessionId {
      get { return result.hasSessionId; }
    }
    public int SessionId {
      get { return result.SessionId; }
      set { SetSessionId(value); }
    }
    public Builder SetSessionId(int value) {
      PrepareBuilder();
      result.hasSessionId = true;
      result.sessionId_ = value;
      return this;
    }
    public Builder ClearSessionId() {
      PrepareBuilder();
      result.hasSessionId = false;
      result.sessionId_ = 0;
      return this;
    }
    
    public bool HasGuid {
      get { return result.hasGuid; }
    }
    public int Guid {
      get { return result.Guid; }
      set { SetGuid(value); }
    }
    public Builder SetGuid(int value) {
      PrepareBuilder();
      result.hasGuid = true;
      result.guid_ = value;
      return this;
    }
    public Builder ClearGuid() {
      PrepareBuilder();
      result.hasGuid = false;
      result.guid_ = 0;
      return this;
    }
  }
  static SCReconnect() {
    object.ReferenceEquals(global::Common.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CSPreCharge : pb::GeneratedMessage<CSPreCharge, CSPreCharge.Builder> {
  private CSPreCharge() { }
  private static readonly CSPreCharge defaultInstance = new CSPreCharge().MakeReadOnly();
  private static readonly string[] _cSPreChargeFieldNames = new string[] { "amount", "cardnumber", "offical", "paymode" };
  private static readonly uint[] _cSPreChargeFieldTags = new uint[] { 16, 10, 32, 24 };
  public static CSPreCharge DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override CSPreCharge DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override CSPreCharge ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Common.internal__static_CSPreCharge__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<CSPreCharge, CSPreCharge.Builder> InternalFieldAccessors {
    get { return global::Common.internal__static_CSPreCharge__FieldAccessorTable; }
  }
  
  public const int CardnumberFieldNumber = 1;
  private bool hasCardnumber;
  private string cardnumber_ = "";
  public bool HasCardnumber {
    get { return hasCardnumber; }
  }
  public string Cardnumber {
    get { return cardnumber_; }
  }
  
  public const int AmountFieldNumber = 2;
  private bool hasAmount;
  private int amount_;
  public bool HasAmount {
    get { return hasAmount; }
  }
  public int Amount {
    get { return amount_; }
  }
  
  public const int PaymodeFieldNumber = 3;
  private bool hasPaymode;
  private int paymode_;
  public bool HasPaymode {
    get { return hasPaymode; }
  }
  public int Paymode {
    get { return paymode_; }
  }
  
  public const int OfficalFieldNumber = 4;
  private bool hasOffical;
  private int offical_;
  public bool HasOffical {
    get { return hasOffical; }
  }
  public int Offical {
    get { return offical_; }
  }
  
  public override bool IsInitialized {
    get {
      if (!hasCardnumber) return false;
      if (!hasAmount) return false;
      if (!hasPaymode) return false;
      if (!hasOffical) return false;
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    CalcSerializedSize();
    string[] field_names = _cSPreChargeFieldNames;
    if (hasCardnumber) {
      output.WriteString(1, field_names[1], Cardnumber);
    }
    if (hasAmount) {
      output.WriteInt32(2, field_names[0], Amount);
    }
    if (hasPaymode) {
      output.WriteInt32(3, field_names[3], Paymode);
    }
    if (hasOffical) {
      output.WriteInt32(4, field_names[2], Offical);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      return CalcSerializedSize();
    }
  }
  
  private int CalcSerializedSize() {
    int size = memoizedSerializedSize;
    if (size != -1) return size;
    
    size = 0;
    if (hasCardnumber) {
      size += pb::CodedOutputStream.ComputeStringSize(1, Cardnumber);
    }
    if (hasAmount) {
      size += pb::CodedOutputStream.ComputeInt32Size(2, Amount);
    }
    if (hasPaymode) {
      size += pb::CodedOutputStream.ComputeInt32Size(3, Paymode);
    }
    if (hasOffical) {
      size += pb::CodedOutputStream.ComputeInt32Size(4, Offical);
    }
    size += UnknownFields.SerializedSize;
    memoizedSerializedSize = size;
    return size;
  }
  public static CSPreCharge ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSPreCharge ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSPreCharge ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSPreCharge ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSPreCharge ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSPreCharge ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static CSPreCharge ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static CSPreCharge ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static CSPreCharge ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSPreCharge ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private CSPreCharge MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(CSPreCharge prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<CSPreCharge, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(CSPreCharge cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private CSPreCharge result;
    
    private CSPreCharge PrepareBuilder() {
      if (resultIsReadOnly) {
        CSPreCharge original = result;
        result = new CSPreCharge();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override CSPreCharge MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::CSPreCharge.Descriptor; }
    }
    
    public override CSPreCharge DefaultInstanceForType {
      get { return global::CSPreCharge.DefaultInstance; }
    }
    
    public override CSPreCharge BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is CSPreCharge) {
        return MergeFrom((CSPreCharge) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(CSPreCharge other) {
      if (other == global::CSPreCharge.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasCardnumber) {
        Cardnumber = other.Cardnumber;
      }
      if (other.HasAmount) {
        Amount = other.Amount;
      }
      if (other.HasPaymode) {
        Paymode = other.Paymode;
      }
      if (other.HasOffical) {
        Offical = other.Offical;
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_cSPreChargeFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _cSPreChargeFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 10: {
            result.hasCardnumber = input.ReadString(ref result.cardnumber_);
            break;
          }
          case 16: {
            result.hasAmount = input.ReadInt32(ref result.amount_);
            break;
          }
          case 24: {
            result.hasPaymode = input.ReadInt32(ref result.paymode_);
            break;
          }
          case 32: {
            result.hasOffical = input.ReadInt32(ref result.offical_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasCardnumber {
      get { return result.hasCardnumber; }
    }
    public string Cardnumber {
      get { return result.Cardnumber; }
      set { SetCardnumber(value); }
    }
    public Builder SetCardnumber(string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasCardnumber = true;
      result.cardnumber_ = value;
      return this;
    }
    public Builder ClearCardnumber() {
      PrepareBuilder();
      result.hasCardnumber = false;
      result.cardnumber_ = "";
      return this;
    }
    
    public bool HasAmount {
      get { return result.hasAmount; }
    }
    public int Amount {
      get { return result.Amount; }
      set { SetAmount(value); }
    }
    public Builder SetAmount(int value) {
      PrepareBuilder();
      result.hasAmount = true;
      result.amount_ = value;
      return this;
    }
    public Builder ClearAmount() {
      PrepareBuilder();
      result.hasAmount = false;
      result.amount_ = 0;
      return this;
    }
    
    public bool HasPaymode {
      get { return result.hasPaymode; }
    }
    public int Paymode {
      get { return result.Paymode; }
      set { SetPaymode(value); }
    }
    public Builder SetPaymode(int value) {
      PrepareBuilder();
      result.hasPaymode = true;
      result.paymode_ = value;
      return this;
    }
    public Builder ClearPaymode() {
      PrepareBuilder();
      result.hasPaymode = false;
      result.paymode_ = 0;
      return this;
    }
    
    public bool HasOffical {
      get { return result.hasOffical; }
    }
    public int Offical {
      get { return result.Offical; }
      set { SetOffical(value); }
    }
    public Builder SetOffical(int value) {
      PrepareBuilder();
      result.hasOffical = true;
      result.offical_ = value;
      return this;
    }
    public Builder ClearOffical() {
      PrepareBuilder();
      result.hasOffical = false;
      result.offical_ = 0;
      return this;
    }
  }
  static CSPreCharge() {
    object.ReferenceEquals(global::Common.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class SCPreCharge : pb::GeneratedMessage<SCPreCharge, SCPreCharge.Builder> {
  private SCPreCharge() { }
  private static readonly SCPreCharge defaultInstance = new SCPreCharge().MakeReadOnly();
  private static readonly string[] _sCPreChargeFieldNames = new string[] { "qrcode" };
  private static readonly uint[] _sCPreChargeFieldTags = new uint[] { 10 };
  public static SCPreCharge DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override SCPreCharge DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override SCPreCharge ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Common.internal__static_SCPreCharge__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<SCPreCharge, SCPreCharge.Builder> InternalFieldAccessors {
    get { return global::Common.internal__static_SCPreCharge__FieldAccessorTable; }
  }
  
  public const int QrcodeFieldNumber = 1;
  private bool hasQrcode;
  private string qrcode_ = "";
  public bool HasQrcode {
    get { return hasQrcode; }
  }
  public string Qrcode {
    get { return qrcode_; }
  }
  
  public override bool IsInitialized {
    get {
      if (!hasQrcode) return false;
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    CalcSerializedSize();
    string[] field_names = _sCPreChargeFieldNames;
    if (hasQrcode) {
      output.WriteString(1, field_names[0], Qrcode);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      return CalcSerializedSize();
    }
  }
  
  private int CalcSerializedSize() {
    int size = memoizedSerializedSize;
    if (size != -1) return size;
    
    size = 0;
    if (hasQrcode) {
      size += pb::CodedOutputStream.ComputeStringSize(1, Qrcode);
    }
    size += UnknownFields.SerializedSize;
    memoizedSerializedSize = size;
    return size;
  }
  public static SCPreCharge ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static SCPreCharge ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static SCPreCharge ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static SCPreCharge ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static SCPreCharge ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static SCPreCharge ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static SCPreCharge ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static SCPreCharge ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static SCPreCharge ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static SCPreCharge ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private SCPreCharge MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(SCPreCharge prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<SCPreCharge, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(SCPreCharge cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private SCPreCharge result;
    
    private SCPreCharge PrepareBuilder() {
      if (resultIsReadOnly) {
        SCPreCharge original = result;
        result = new SCPreCharge();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override SCPreCharge MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::SCPreCharge.Descriptor; }
    }
    
    public override SCPreCharge DefaultInstanceForType {
      get { return global::SCPreCharge.DefaultInstance; }
    }
    
    public override SCPreCharge BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is SCPreCharge) {
        return MergeFrom((SCPreCharge) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(SCPreCharge other) {
      if (other == global::SCPreCharge.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasQrcode) {
        Qrcode = other.Qrcode;
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_sCPreChargeFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _sCPreChargeFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 10: {
            result.hasQrcode = input.ReadString(ref result.qrcode_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasQrcode {
      get { return result.hasQrcode; }
    }
    public string Qrcode {
      get { return result.Qrcode; }
      set { SetQrcode(value); }
    }
    public Builder SetQrcode(string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasQrcode = true;
      result.qrcode_ = value;
      return this;
    }
    public Builder ClearQrcode() {
      PrepareBuilder();
      result.hasQrcode = false;
      result.qrcode_ = "";
      return this;
    }
  }
  static SCPreCharge() {
    object.ReferenceEquals(global::Common.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class SCToCharge : pb::GeneratedMessage<SCToCharge, SCToCharge.Builder> {
  private SCToCharge() { }
  private static readonly SCToCharge defaultInstance = new SCToCharge().MakeReadOnly();
  private static readonly string[] _sCToChargeFieldNames = new string[] { "balance", "cardnumber", "integal", "name", "recharge", "right" };
  private static readonly uint[] _sCToChargeFieldTags = new uint[] { 40, 18, 48, 10, 32, 26 };
  public static SCToCharge DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override SCToCharge DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override SCToCharge ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Common.internal__static_SCToCharge__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<SCToCharge, SCToCharge.Builder> InternalFieldAccessors {
    get { return global::Common.internal__static_SCToCharge__FieldAccessorTable; }
  }
  
  public const int NameFieldNumber = 1;
  private bool hasName;
  private string name_ = "";
  public bool HasName {
    get { return hasName; }
  }
  public string Name {
    get { return name_; }
  }
  
  public const int CardnumberFieldNumber = 2;
  private bool hasCardnumber;
  private string cardnumber_ = "";
  public bool HasCardnumber {
    get { return hasCardnumber; }
  }
  public string Cardnumber {
    get { return cardnumber_; }
  }
  
  public const int RightFieldNumber = 3;
  private bool hasRight;
  private string right_ = "";
  public bool HasRight {
    get { return hasRight; }
  }
  public string Right {
    get { return right_; }
  }
  
  public const int RechargeFieldNumber = 4;
  private bool hasRecharge;
  private int recharge_;
  public bool HasRecharge {
    get { return hasRecharge; }
  }
  public int Recharge {
    get { return recharge_; }
  }
  
  public const int BalanceFieldNumber = 5;
  private bool hasBalance;
  private int balance_;
  public bool HasBalance {
    get { return hasBalance; }
  }
  public int Balance {
    get { return balance_; }
  }
  
  public const int IntegalFieldNumber = 6;
  private bool hasIntegal;
  private int integal_;
  public bool HasIntegal {
    get { return hasIntegal; }
  }
  public int Integal {
    get { return integal_; }
  }
  
  public override bool IsInitialized {
    get {
      if (!hasName) return false;
      if (!hasCardnumber) return false;
      if (!hasRight) return false;
      if (!hasRecharge) return false;
      if (!hasBalance) return false;
      if (!hasIntegal) return false;
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    CalcSerializedSize();
    string[] field_names = _sCToChargeFieldNames;
    if (hasName) {
      output.WriteString(1, field_names[3], Name);
    }
    if (hasCardnumber) {
      output.WriteString(2, field_names[1], Cardnumber);
    }
    if (hasRight) {
      output.WriteString(3, field_names[5], Right);
    }
    if (hasRecharge) {
      output.WriteInt32(4, field_names[4], Recharge);
    }
    if (hasBalance) {
      output.WriteInt32(5, field_names[0], Balance);
    }
    if (hasIntegal) {
      output.WriteInt32(6, field_names[2], Integal);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      return CalcSerializedSize();
    }
  }
  
  private int CalcSerializedSize() {
    int size = memoizedSerializedSize;
    if (size != -1) return size;
    
    size = 0;
    if (hasName) {
      size += pb::CodedOutputStream.ComputeStringSize(1, Name);
    }
    if (hasCardnumber) {
      size += pb::CodedOutputStream.ComputeStringSize(2, Cardnumber);
    }
    if (hasRight) {
      size += pb::CodedOutputStream.ComputeStringSize(3, Right);
    }
    if (hasRecharge) {
      size += pb::CodedOutputStream.ComputeInt32Size(4, Recharge);
    }
    if (hasBalance) {
      size += pb::CodedOutputStream.ComputeInt32Size(5, Balance);
    }
    if (hasIntegal) {
      size += pb::CodedOutputStream.ComputeInt32Size(6, Integal);
    }
    size += UnknownFields.SerializedSize;
    memoizedSerializedSize = size;
    return size;
  }
  public static SCToCharge ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static SCToCharge ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static SCToCharge ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static SCToCharge ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static SCToCharge ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static SCToCharge ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static SCToCharge ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static SCToCharge ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static SCToCharge ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static SCToCharge ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private SCToCharge MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(SCToCharge prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<SCToCharge, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(SCToCharge cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private SCToCharge result;
    
    private SCToCharge PrepareBuilder() {
      if (resultIsReadOnly) {
        SCToCharge original = result;
        result = new SCToCharge();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override SCToCharge MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::SCToCharge.Descriptor; }
    }
    
    public override SCToCharge DefaultInstanceForType {
      get { return global::SCToCharge.DefaultInstance; }
    }
    
    public override SCToCharge BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is SCToCharge) {
        return MergeFrom((SCToCharge) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(SCToCharge other) {
      if (other == global::SCToCharge.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasName) {
        Name = other.Name;
      }
      if (other.HasCardnumber) {
        Cardnumber = other.Cardnumber;
      }
      if (other.HasRight) {
        Right = other.Right;
      }
      if (other.HasRecharge) {
        Recharge = other.Recharge;
      }
      if (other.HasBalance) {
        Balance = other.Balance;
      }
      if (other.HasIntegal) {
        Integal = other.Integal;
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_sCToChargeFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _sCToChargeFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 10: {
            result.hasName = input.ReadString(ref result.name_);
            break;
          }
          case 18: {
            result.hasCardnumber = input.ReadString(ref result.cardnumber_);
            break;
          }
          case 26: {
            result.hasRight = input.ReadString(ref result.right_);
            break;
          }
          case 32: {
            result.hasRecharge = input.ReadInt32(ref result.recharge_);
            break;
          }
          case 40: {
            result.hasBalance = input.ReadInt32(ref result.balance_);
            break;
          }
          case 48: {
            result.hasIntegal = input.ReadInt32(ref result.integal_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasName {
      get { return result.hasName; }
    }
    public string Name {
      get { return result.Name; }
      set { SetName(value); }
    }
    public Builder SetName(string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasName = true;
      result.name_ = value;
      return this;
    }
    public Builder ClearName() {
      PrepareBuilder();
      result.hasName = false;
      result.name_ = "";
      return this;
    }
    
    public bool HasCardnumber {
      get { return result.hasCardnumber; }
    }
    public string Cardnumber {
      get { return result.Cardnumber; }
      set { SetCardnumber(value); }
    }
    public Builder SetCardnumber(string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasCardnumber = true;
      result.cardnumber_ = value;
      return this;
    }
    public Builder ClearCardnumber() {
      PrepareBuilder();
      result.hasCardnumber = false;
      result.cardnumber_ = "";
      return this;
    }
    
    public bool HasRight {
      get { return result.hasRight; }
    }
    public string Right {
      get { return result.Right; }
      set { SetRight(value); }
    }
    public Builder SetRight(string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasRight = true;
      result.right_ = value;
      return this;
    }
    public Builder ClearRight() {
      PrepareBuilder();
      result.hasRight = false;
      result.right_ = "";
      return this;
    }
    
    public bool HasRecharge {
      get { return result.hasRecharge; }
    }
    public int Recharge {
      get { return result.Recharge; }
      set { SetRecharge(value); }
    }
    public Builder SetRecharge(int value) {
      PrepareBuilder();
      result.hasRecharge = true;
      result.recharge_ = value;
      return this;
    }
    public Builder ClearRecharge() {
      PrepareBuilder();
      result.hasRecharge = false;
      result.recharge_ = 0;
      return this;
    }
    
    public bool HasBalance {
      get { return result.hasBalance; }
    }
    public int Balance {
      get { return result.Balance; }
      set { SetBalance(value); }
    }
    public Builder SetBalance(int value) {
      PrepareBuilder();
      result.hasBalance = true;
      result.balance_ = value;
      return this;
    }
    public Builder ClearBalance() {
      PrepareBuilder();
      result.hasBalance = false;
      result.balance_ = 0;
      return this;
    }
    
    public bool HasIntegal {
      get { return result.hasIntegal; }
    }
    public int Integal {
      get { return result.Integal; }
      set { SetIntegal(value); }
    }
    public Builder SetIntegal(int value) {
      PrepareBuilder();
      result.hasIntegal = true;
      result.integal_ = value;
      return this;
    }
    public Builder ClearIntegal() {
      PrepareBuilder();
      result.hasIntegal = false;
      result.integal_ = 0;
      return this;
    }
  }
  static SCToCharge() {
    object.ReferenceEquals(global::Common.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CSPreBuy : pb::GeneratedMessage<CSPreBuy, CSPreBuy.Builder> {
  private CSPreBuy() { }
  private static readonly CSPreBuy defaultInstance = new CSPreBuy().MakeReadOnly();
  private static readonly string[] _cSPreBuyFieldNames = new string[] { "cardnumber", "goodsid", "goodsnum" };
  private static readonly uint[] _cSPreBuyFieldTags = new uint[] { 10, 16, 24 };
  public static CSPreBuy DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override CSPreBuy DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override CSPreBuy ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Common.internal__static_CSPreBuy__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<CSPreBuy, CSPreBuy.Builder> InternalFieldAccessors {
    get { return global::Common.internal__static_CSPreBuy__FieldAccessorTable; }
  }
  
  public const int CardnumberFieldNumber = 1;
  private bool hasCardnumber;
  private string cardnumber_ = "";
  public bool HasCardnumber {
    get { return hasCardnumber; }
  }
  public string Cardnumber {
    get { return cardnumber_; }
  }
  
  public const int GoodsidFieldNumber = 2;
  private bool hasGoodsid;
  private int goodsid_;
  public bool HasGoodsid {
    get { return hasGoodsid; }
  }
  public int Goodsid {
    get { return goodsid_; }
  }
  
  public const int GoodsnumFieldNumber = 3;
  private bool hasGoodsnum;
  private int goodsnum_;
  public bool HasGoodsnum {
    get { return hasGoodsnum; }
  }
  public int Goodsnum {
    get { return goodsnum_; }
  }
  
  public override bool IsInitialized {
    get {
      if (!hasCardnumber) return false;
      if (!hasGoodsid) return false;
      if (!hasGoodsnum) return false;
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    CalcSerializedSize();
    string[] field_names = _cSPreBuyFieldNames;
    if (hasCardnumber) {
      output.WriteString(1, field_names[0], Cardnumber);
    }
    if (hasGoodsid) {
      output.WriteInt32(2, field_names[1], Goodsid);
    }
    if (hasGoodsnum) {
      output.WriteInt32(3, field_names[2], Goodsnum);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      return CalcSerializedSize();
    }
  }
  
  private int CalcSerializedSize() {
    int size = memoizedSerializedSize;
    if (size != -1) return size;
    
    size = 0;
    if (hasCardnumber) {
      size += pb::CodedOutputStream.ComputeStringSize(1, Cardnumber);
    }
    if (hasGoodsid) {
      size += pb::CodedOutputStream.ComputeInt32Size(2, Goodsid);
    }
    if (hasGoodsnum) {
      size += pb::CodedOutputStream.ComputeInt32Size(3, Goodsnum);
    }
    size += UnknownFields.SerializedSize;
    memoizedSerializedSize = size;
    return size;
  }
  public static CSPreBuy ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSPreBuy ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSPreBuy ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSPreBuy ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSPreBuy ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSPreBuy ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static CSPreBuy ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static CSPreBuy ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static CSPreBuy ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSPreBuy ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private CSPreBuy MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(CSPreBuy prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<CSPreBuy, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(CSPreBuy cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private CSPreBuy result;
    
    private CSPreBuy PrepareBuilder() {
      if (resultIsReadOnly) {
        CSPreBuy original = result;
        result = new CSPreBuy();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override CSPreBuy MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::CSPreBuy.Descriptor; }
    }
    
    public override CSPreBuy DefaultInstanceForType {
      get { return global::CSPreBuy.DefaultInstance; }
    }
    
    public override CSPreBuy BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is CSPreBuy) {
        return MergeFrom((CSPreBuy) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(CSPreBuy other) {
      if (other == global::CSPreBuy.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasCardnumber) {
        Cardnumber = other.Cardnumber;
      }
      if (other.HasGoodsid) {
        Goodsid = other.Goodsid;
      }
      if (other.HasGoodsnum) {
        Goodsnum = other.Goodsnum;
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_cSPreBuyFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _cSPreBuyFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 10: {
            result.hasCardnumber = input.ReadString(ref result.cardnumber_);
            break;
          }
          case 16: {
            result.hasGoodsid = input.ReadInt32(ref result.goodsid_);
            break;
          }
          case 24: {
            result.hasGoodsnum = input.ReadInt32(ref result.goodsnum_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasCardnumber {
      get { return result.hasCardnumber; }
    }
    public string Cardnumber {
      get { return result.Cardnumber; }
      set { SetCardnumber(value); }
    }
    public Builder SetCardnumber(string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasCardnumber = true;
      result.cardnumber_ = value;
      return this;
    }
    public Builder ClearCardnumber() {
      PrepareBuilder();
      result.hasCardnumber = false;
      result.cardnumber_ = "";
      return this;
    }
    
    public bool HasGoodsid {
      get { return result.hasGoodsid; }
    }
    public int Goodsid {
      get { return result.Goodsid; }
      set { SetGoodsid(value); }
    }
    public Builder SetGoodsid(int value) {
      PrepareBuilder();
      result.hasGoodsid = true;
      result.goodsid_ = value;
      return this;
    }
    public Builder ClearGoodsid() {
      PrepareBuilder();
      result.hasGoodsid = false;
      result.goodsid_ = 0;
      return this;
    }
    
    public bool HasGoodsnum {
      get { return result.hasGoodsnum; }
    }
    public int Goodsnum {
      get { return result.Goodsnum; }
      set { SetGoodsnum(value); }
    }
    public Builder SetGoodsnum(int value) {
      PrepareBuilder();
      result.hasGoodsnum = true;
      result.goodsnum_ = value;
      return this;
    }
    public Builder ClearGoodsnum() {
      PrepareBuilder();
      result.hasGoodsnum = false;
      result.goodsnum_ = 0;
      return this;
    }
  }
  static CSPreBuy() {
    object.ReferenceEquals(global::Common.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class SCPreBuy : pb::GeneratedMessage<SCPreBuy, SCPreBuy.Builder> {
  private SCPreBuy() { }
  private static readonly SCPreBuy defaultInstance = new SCPreBuy().MakeReadOnly();
  private static readonly string[] _sCPreBuyFieldNames = new string[] { "qrcode" };
  private static readonly uint[] _sCPreBuyFieldTags = new uint[] { 10 };
  public static SCPreBuy DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override SCPreBuy DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override SCPreBuy ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Common.internal__static_SCPreBuy__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<SCPreBuy, SCPreBuy.Builder> InternalFieldAccessors {
    get { return global::Common.internal__static_SCPreBuy__FieldAccessorTable; }
  }
  
  public const int QrcodeFieldNumber = 1;
  private bool hasQrcode;
  private string qrcode_ = "";
  public bool HasQrcode {
    get { return hasQrcode; }
  }
  public string Qrcode {
    get { return qrcode_; }
  }
  
  public override bool IsInitialized {
    get {
      if (!hasQrcode) return false;
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    CalcSerializedSize();
    string[] field_names = _sCPreBuyFieldNames;
    if (hasQrcode) {
      output.WriteString(1, field_names[0], Qrcode);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      return CalcSerializedSize();
    }
  }
  
  private int CalcSerializedSize() {
    int size = memoizedSerializedSize;
    if (size != -1) return size;
    
    size = 0;
    if (hasQrcode) {
      size += pb::CodedOutputStream.ComputeStringSize(1, Qrcode);
    }
    size += UnknownFields.SerializedSize;
    memoizedSerializedSize = size;
    return size;
  }
  public static SCPreBuy ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static SCPreBuy ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static SCPreBuy ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static SCPreBuy ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static SCPreBuy ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static SCPreBuy ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static SCPreBuy ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static SCPreBuy ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static SCPreBuy ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static SCPreBuy ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private SCPreBuy MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(SCPreBuy prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<SCPreBuy, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(SCPreBuy cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private SCPreBuy result;
    
    private SCPreBuy PrepareBuilder() {
      if (resultIsReadOnly) {
        SCPreBuy original = result;
        result = new SCPreBuy();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override SCPreBuy MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::SCPreBuy.Descriptor; }
    }
    
    public override SCPreBuy DefaultInstanceForType {
      get { return global::SCPreBuy.DefaultInstance; }
    }
    
    public override SCPreBuy BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is SCPreBuy) {
        return MergeFrom((SCPreBuy) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(SCPreBuy other) {
      if (other == global::SCPreBuy.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasQrcode) {
        Qrcode = other.Qrcode;
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_sCPreBuyFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _sCPreBuyFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 10: {
            result.hasQrcode = input.ReadString(ref result.qrcode_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasQrcode {
      get { return result.hasQrcode; }
    }
    public string Qrcode {
      get { return result.Qrcode; }
      set { SetQrcode(value); }
    }
    public Builder SetQrcode(string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasQrcode = true;
      result.qrcode_ = value;
      return this;
    }
    public Builder ClearQrcode() {
      PrepareBuilder();
      result.hasQrcode = false;
      result.qrcode_ = "";
      return this;
    }
  }
  static SCPreBuy() {
    object.ReferenceEquals(global::Common.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class SCToBuy : pb::GeneratedMessage<SCToBuy, SCToBuy.Builder> {
  private SCToBuy() { }
  private static readonly SCToBuy defaultInstance = new SCToBuy().MakeReadOnly();
  private static readonly string[] _sCToBuyFieldNames = new string[] { "balance", "cardnumber", "integal", "name", "right", "usedintegal", "usedmoney" };
  private static readonly uint[] _sCToBuyFieldTags = new uint[] { 48, 18, 56, 10, 26, 40, 32 };
  public static SCToBuy DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override SCToBuy DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override SCToBuy ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Common.internal__static_SCToBuy__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<SCToBuy, SCToBuy.Builder> InternalFieldAccessors {
    get { return global::Common.internal__static_SCToBuy__FieldAccessorTable; }
  }
  
  public const int NameFieldNumber = 1;
  private bool hasName;
  private string name_ = "";
  public bool HasName {
    get { return hasName; }
  }
  public string Name {
    get { return name_; }
  }
  
  public const int CardnumberFieldNumber = 2;
  private bool hasCardnumber;
  private string cardnumber_ = "";
  public bool HasCardnumber {
    get { return hasCardnumber; }
  }
  public string Cardnumber {
    get { return cardnumber_; }
  }
  
  public const int RightFieldNumber = 3;
  private bool hasRight;
  private string right_ = "";
  public bool HasRight {
    get { return hasRight; }
  }
  public string Right {
    get { return right_; }
  }
  
  public const int UsedmoneyFieldNumber = 4;
  private bool hasUsedmoney;
  private int usedmoney_;
  public bool HasUsedmoney {
    get { return hasUsedmoney; }
  }
  public int Usedmoney {
    get { return usedmoney_; }
  }
  
  public const int UsedintegalFieldNumber = 5;
  private bool hasUsedintegal;
  private int usedintegal_;
  public bool HasUsedintegal {
    get { return hasUsedintegal; }
  }
  public int Usedintegal {
    get { return usedintegal_; }
  }
  
  public const int BalanceFieldNumber = 6;
  private bool hasBalance;
  private int balance_;
  public bool HasBalance {
    get { return hasBalance; }
  }
  public int Balance {
    get { return balance_; }
  }
  
  public const int IntegalFieldNumber = 7;
  private bool hasIntegal;
  private int integal_;
  public bool HasIntegal {
    get { return hasIntegal; }
  }
  public int Integal {
    get { return integal_; }
  }
  
  public override bool IsInitialized {
    get {
      if (!hasName) return false;
      if (!hasCardnumber) return false;
      if (!hasRight) return false;
      if (!hasUsedmoney) return false;
      if (!hasUsedintegal) return false;
      if (!hasBalance) return false;
      if (!hasIntegal) return false;
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    CalcSerializedSize();
    string[] field_names = _sCToBuyFieldNames;
    if (hasName) {
      output.WriteString(1, field_names[3], Name);
    }
    if (hasCardnumber) {
      output.WriteString(2, field_names[1], Cardnumber);
    }
    if (hasRight) {
      output.WriteString(3, field_names[4], Right);
    }
    if (hasUsedmoney) {
      output.WriteInt32(4, field_names[6], Usedmoney);
    }
    if (hasUsedintegal) {
      output.WriteInt32(5, field_names[5], Usedintegal);
    }
    if (hasBalance) {
      output.WriteInt32(6, field_names[0], Balance);
    }
    if (hasIntegal) {
      output.WriteInt32(7, field_names[2], Integal);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      return CalcSerializedSize();
    }
  }
  
  private int CalcSerializedSize() {
    int size = memoizedSerializedSize;
    if (size != -1) return size;
    
    size = 0;
    if (hasName) {
      size += pb::CodedOutputStream.ComputeStringSize(1, Name);
    }
    if (hasCardnumber) {
      size += pb::CodedOutputStream.ComputeStringSize(2, Cardnumber);
    }
    if (hasRight) {
      size += pb::CodedOutputStream.ComputeStringSize(3, Right);
    }
    if (hasUsedmoney) {
      size += pb::CodedOutputStream.ComputeInt32Size(4, Usedmoney);
    }
    if (hasUsedintegal) {
      size += pb::CodedOutputStream.ComputeInt32Size(5, Usedintegal);
    }
    if (hasBalance) {
      size += pb::CodedOutputStream.ComputeInt32Size(6, Balance);
    }
    if (hasIntegal) {
      size += pb::CodedOutputStream.ComputeInt32Size(7, Integal);
    }
    size += UnknownFields.SerializedSize;
    memoizedSerializedSize = size;
    return size;
  }
  public static SCToBuy ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static SCToBuy ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static SCToBuy ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static SCToBuy ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static SCToBuy ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static SCToBuy ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static SCToBuy ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static SCToBuy ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static SCToBuy ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static SCToBuy ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private SCToBuy MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(SCToBuy prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<SCToBuy, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(SCToBuy cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private SCToBuy result;
    
    private SCToBuy PrepareBuilder() {
      if (resultIsReadOnly) {
        SCToBuy original = result;
        result = new SCToBuy();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override SCToBuy MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::SCToBuy.Descriptor; }
    }
    
    public override SCToBuy DefaultInstanceForType {
      get { return global::SCToBuy.DefaultInstance; }
    }
    
    public override SCToBuy BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is SCToBuy) {
        return MergeFrom((SCToBuy) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(SCToBuy other) {
      if (other == global::SCToBuy.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasName) {
        Name = other.Name;
      }
      if (other.HasCardnumber) {
        Cardnumber = other.Cardnumber;
      }
      if (other.HasRight) {
        Right = other.Right;
      }
      if (other.HasUsedmoney) {
        Usedmoney = other.Usedmoney;
      }
      if (other.HasUsedintegal) {
        Usedintegal = other.Usedintegal;
      }
      if (other.HasBalance) {
        Balance = other.Balance;
      }
      if (other.HasIntegal) {
        Integal = other.Integal;
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_sCToBuyFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _sCToBuyFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 10: {
            result.hasName = input.ReadString(ref result.name_);
            break;
          }
          case 18: {
            result.hasCardnumber = input.ReadString(ref result.cardnumber_);
            break;
          }
          case 26: {
            result.hasRight = input.ReadString(ref result.right_);
            break;
          }
          case 32: {
            result.hasUsedmoney = input.ReadInt32(ref result.usedmoney_);
            break;
          }
          case 40: {
            result.hasUsedintegal = input.ReadInt32(ref result.usedintegal_);
            break;
          }
          case 48: {
            result.hasBalance = input.ReadInt32(ref result.balance_);
            break;
          }
          case 56: {
            result.hasIntegal = input.ReadInt32(ref result.integal_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasName {
      get { return result.hasName; }
    }
    public string Name {
      get { return result.Name; }
      set { SetName(value); }
    }
    public Builder SetName(string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasName = true;
      result.name_ = value;
      return this;
    }
    public Builder ClearName() {
      PrepareBuilder();
      result.hasName = false;
      result.name_ = "";
      return this;
    }
    
    public bool HasCardnumber {
      get { return result.hasCardnumber; }
    }
    public string Cardnumber {
      get { return result.Cardnumber; }
      set { SetCardnumber(value); }
    }
    public Builder SetCardnumber(string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasCardnumber = true;
      result.cardnumber_ = value;
      return this;
    }
    public Builder ClearCardnumber() {
      PrepareBuilder();
      result.hasCardnumber = false;
      result.cardnumber_ = "";
      return this;
    }
    
    public bool HasRight {
      get { return result.hasRight; }
    }
    public string Right {
      get { return result.Right; }
      set { SetRight(value); }
    }
    public Builder SetRight(string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasRight = true;
      result.right_ = value;
      return this;
    }
    public Builder ClearRight() {
      PrepareBuilder();
      result.hasRight = false;
      result.right_ = "";
      return this;
    }
    
    public bool HasUsedmoney {
      get { return result.hasUsedmoney; }
    }
    public int Usedmoney {
      get { return result.Usedmoney; }
      set { SetUsedmoney(value); }
    }
    public Builder SetUsedmoney(int value) {
      PrepareBuilder();
      result.hasUsedmoney = true;
      result.usedmoney_ = value;
      return this;
    }
    public Builder ClearUsedmoney() {
      PrepareBuilder();
      result.hasUsedmoney = false;
      result.usedmoney_ = 0;
      return this;
    }
    
    public bool HasUsedintegal {
      get { return result.hasUsedintegal; }
    }
    public int Usedintegal {
      get { return result.Usedintegal; }
      set { SetUsedintegal(value); }
    }
    public Builder SetUsedintegal(int value) {
      PrepareBuilder();
      result.hasUsedintegal = true;
      result.usedintegal_ = value;
      return this;
    }
    public Builder ClearUsedintegal() {
      PrepareBuilder();
      result.hasUsedintegal = false;
      result.usedintegal_ = 0;
      return this;
    }
    
    public bool HasBalance {
      get { return result.hasBalance; }
    }
    public int Balance {
      get { return result.Balance; }
      set { SetBalance(value); }
    }
    public Builder SetBalance(int value) {
      PrepareBuilder();
      result.hasBalance = true;
      result.balance_ = value;
      return this;
    }
    public Builder ClearBalance() {
      PrepareBuilder();
      result.hasBalance = false;
      result.balance_ = 0;
      return this;
    }
    
    public bool HasIntegal {
      get { return result.hasIntegal; }
    }
    public int Integal {
      get { return result.Integal; }
      set { SetIntegal(value); }
    }
    public Builder SetIntegal(int value) {
      PrepareBuilder();
      result.hasIntegal = true;
      result.integal_ = value;
      return this;
    }
    public Builder ClearIntegal() {
      PrepareBuilder();
      result.hasIntegal = false;
      result.integal_ = 0;
      return this;
    }
  }
  static SCToBuy() {
    object.ReferenceEquals(global::Common.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class SCMessage : pb::GeneratedMessage<SCMessage, SCMessage.Builder> {
  private SCMessage() { }
  private static readonly SCMessage defaultInstance = new SCMessage().MakeReadOnly();
  private static readonly string[] _sCMessageFieldNames = new string[] { "cmd", "params" };
  private static readonly uint[] _sCMessageFieldTags = new uint[] { 8, 18 };
  public static SCMessage DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override SCMessage DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override SCMessage ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Common.internal__static_SCMessage__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<SCMessage, SCMessage.Builder> InternalFieldAccessors {
    get { return global::Common.internal__static_SCMessage__FieldAccessorTable; }
  }
  
  public const int CmdFieldNumber = 1;
  private bool hasCmd;
  private int cmd_;
  public bool HasCmd {
    get { return hasCmd; }
  }
  public int Cmd {
    get { return cmd_; }
  }
  
  public const int ParamsFieldNumber = 2;
  private pbc::PopsicleList<string> params_ = new pbc::PopsicleList<string>();
  public scg::IList<string> ParamsList {
    get { return pbc::Lists.AsReadOnly(params_); }
  }
  public int ParamsCount {
    get { return params_.Count; }
  }
  public string GetParams(int index) {
    return params_[index];
  }
  
  public override bool IsInitialized {
    get {
      if (!hasCmd) return false;
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    CalcSerializedSize();
    string[] field_names = _sCMessageFieldNames;
    if (hasCmd) {
      output.WriteInt32(1, field_names[0], Cmd);
    }
    if (params_.Count > 0) {
      output.WriteStringArray(2, field_names[1], params_);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      return CalcSerializedSize();
    }
  }
  
  private int CalcSerializedSize() {
    int size = memoizedSerializedSize;
    if (size != -1) return size;
    
    size = 0;
    if (hasCmd) {
      size += pb::CodedOutputStream.ComputeInt32Size(1, Cmd);
    }
    {
      int dataSize = 0;
      foreach (string element in ParamsList) {
        dataSize += pb::CodedOutputStream.ComputeStringSizeNoTag(element);
      }
      size += dataSize;
      size += 1 * params_.Count;
    }
    size += UnknownFields.SerializedSize;
    memoizedSerializedSize = size;
    return size;
  }
  public static SCMessage ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static SCMessage ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static SCMessage ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static SCMessage ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static SCMessage ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static SCMessage ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static SCMessage ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static SCMessage ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static SCMessage ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static SCMessage ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private SCMessage MakeReadOnly() {
    params_.MakeReadOnly();
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(SCMessage prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<SCMessage, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(SCMessage cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private SCMessage result;
    
    private SCMessage PrepareBuilder() {
      if (resultIsReadOnly) {
        SCMessage original = result;
        result = new SCMessage();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override SCMessage MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::SCMessage.Descriptor; }
    }
    
    public override SCMessage DefaultInstanceForType {
      get { return global::SCMessage.DefaultInstance; }
    }
    
    public override SCMessage BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is SCMessage) {
        return MergeFrom((SCMessage) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(SCMessage other) {
      if (other == global::SCMessage.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasCmd) {
        Cmd = other.Cmd;
      }
      if (other.params_.Count != 0) {
        result.params_.Add(other.params_);
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_sCMessageFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _sCMessageFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 8: {
            result.hasCmd = input.ReadInt32(ref result.cmd_);
            break;
          }
          case 18: {
            input.ReadStringArray(tag, field_name, result.params_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasCmd {
      get { return result.hasCmd; }
    }
    public int Cmd {
      get { return result.Cmd; }
      set { SetCmd(value); }
    }
    public Builder SetCmd(int value) {
      PrepareBuilder();
      result.hasCmd = true;
      result.cmd_ = value;
      return this;
    }
    public Builder ClearCmd() {
      PrepareBuilder();
      result.hasCmd = false;
      result.cmd_ = 0;
      return this;
    }
    
    public pbc::IPopsicleList<string> ParamsList {
      get { return PrepareBuilder().params_; }
    }
    public int ParamsCount {
      get { return result.ParamsCount; }
    }
    public string GetParams(int index) {
      return result.GetParams(index);
    }
    public Builder SetParams(int index, string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.params_[index] = value;
      return this;
    }
    public Builder AddParams(string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.params_.Add(value);
      return this;
    }
    public Builder AddRangeParams(scg::IEnumerable<string> values) {
      PrepareBuilder();
      result.params_.Add(values);
      return this;
    }
    public Builder ClearParams() {
      PrepareBuilder();
      result.params_.Clear();
      return this;
    }
  }
  static SCMessage() {
    object.ReferenceEquals(global::Common.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CSCommand : pb::GeneratedMessage<CSCommand, CSCommand.Builder> {
  private CSCommand() { }
  private static readonly CSCommand defaultInstance = new CSCommand().MakeReadOnly();
  private static readonly string[] _cSCommandFieldNames = new string[] { "cmd", "params" };
  private static readonly uint[] _cSCommandFieldTags = new uint[] { 8, 18 };
  public static CSCommand DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override CSCommand DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override CSCommand ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Common.internal__static_CSCommand__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<CSCommand, CSCommand.Builder> InternalFieldAccessors {
    get { return global::Common.internal__static_CSCommand__FieldAccessorTable; }
  }
  
  public const int CmdFieldNumber = 1;
  private bool hasCmd;
  private int cmd_;
  public bool HasCmd {
    get { return hasCmd; }
  }
  public int Cmd {
    get { return cmd_; }
  }
  
  public const int ParamsFieldNumber = 2;
  private pbc::PopsicleList<string> params_ = new pbc::PopsicleList<string>();
  public scg::IList<string> ParamsList {
    get { return pbc::Lists.AsReadOnly(params_); }
  }
  public int ParamsCount {
    get { return params_.Count; }
  }
  public string GetParams(int index) {
    return params_[index];
  }
  
  public override bool IsInitialized {
    get {
      if (!hasCmd) return false;
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    CalcSerializedSize();
    string[] field_names = _cSCommandFieldNames;
    if (hasCmd) {
      output.WriteInt32(1, field_names[0], Cmd);
    }
    if (params_.Count > 0) {
      output.WriteStringArray(2, field_names[1], params_);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      return CalcSerializedSize();
    }
  }
  
  private int CalcSerializedSize() {
    int size = memoizedSerializedSize;
    if (size != -1) return size;
    
    size = 0;
    if (hasCmd) {
      size += pb::CodedOutputStream.ComputeInt32Size(1, Cmd);
    }
    {
      int dataSize = 0;
      foreach (string element in ParamsList) {
        dataSize += pb::CodedOutputStream.ComputeStringSizeNoTag(element);
      }
      size += dataSize;
      size += 1 * params_.Count;
    }
    size += UnknownFields.SerializedSize;
    memoizedSerializedSize = size;
    return size;
  }
  public static CSCommand ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSCommand ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSCommand ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSCommand ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSCommand ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSCommand ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static CSCommand ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static CSCommand ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static CSCommand ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSCommand ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private CSCommand MakeReadOnly() {
    params_.MakeReadOnly();
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(CSCommand prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<CSCommand, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(CSCommand cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private CSCommand result;
    
    private CSCommand PrepareBuilder() {
      if (resultIsReadOnly) {
        CSCommand original = result;
        result = new CSCommand();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override CSCommand MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::CSCommand.Descriptor; }
    }
    
    public override CSCommand DefaultInstanceForType {
      get { return global::CSCommand.DefaultInstance; }
    }
    
    public override CSCommand BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is CSCommand) {
        return MergeFrom((CSCommand) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(CSCommand other) {
      if (other == global::CSCommand.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasCmd) {
        Cmd = other.Cmd;
      }
      if (other.params_.Count != 0) {
        result.params_.Add(other.params_);
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_cSCommandFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _cSCommandFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 8: {
            result.hasCmd = input.ReadInt32(ref result.cmd_);
            break;
          }
          case 18: {
            input.ReadStringArray(tag, field_name, result.params_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasCmd {
      get { return result.hasCmd; }
    }
    public int Cmd {
      get { return result.Cmd; }
      set { SetCmd(value); }
    }
    public Builder SetCmd(int value) {
      PrepareBuilder();
      result.hasCmd = true;
      result.cmd_ = value;
      return this;
    }
    public Builder ClearCmd() {
      PrepareBuilder();
      result.hasCmd = false;
      result.cmd_ = 0;
      return this;
    }
    
    public pbc::IPopsicleList<string> ParamsList {
      get { return PrepareBuilder().params_; }
    }
    public int ParamsCount {
      get { return result.ParamsCount; }
    }
    public string GetParams(int index) {
      return result.GetParams(index);
    }
    public Builder SetParams(int index, string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.params_[index] = value;
      return this;
    }
    public Builder AddParams(string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.params_.Add(value);
      return this;
    }
    public Builder AddRangeParams(scg::IEnumerable<string> values) {
      PrepareBuilder();
      result.params_.Add(values);
      return this;
    }
    public Builder ClearParams() {
      PrepareBuilder();
      result.params_.Clear();
      return this;
    }
  }
  static CSCommand() {
    object.ReferenceEquals(global::Common.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CSGoodsFind : pb::GeneratedMessage<CSGoodsFind, CSGoodsFind.Builder> {
  private CSGoodsFind() { }
  private static readonly CSGoodsFind defaultInstance = new CSGoodsFind().MakeReadOnly();
  private static readonly string[] _cSGoodsFindFieldNames = new string[] { "category", "keywords", "page" };
  private static readonly uint[] _cSGoodsFindFieldTags = new uint[] { 16, 34, 10 };
  public static CSGoodsFind DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override CSGoodsFind DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override CSGoodsFind ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Common.internal__static_CSGoodsFind__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<CSGoodsFind, CSGoodsFind.Builder> InternalFieldAccessors {
    get { return global::Common.internal__static_CSGoodsFind__FieldAccessorTable; }
  }
  
  public const int PageFieldNumber = 1;
  private bool hasPage;
  private global::StructPage page_;
  public bool HasPage {
    get { return hasPage; }
  }
  public global::StructPage Page {
    get { return page_ ?? global::StructPage.DefaultInstance; }
  }
  
  public const int CategoryFieldNumber = 2;
  private bool hasCategory;
  private int category_;
  public bool HasCategory {
    get { return hasCategory; }
  }
  public int Category {
    get { return category_; }
  }
  
  public const int KeywordsFieldNumber = 4;
  private bool hasKeywords;
  private string keywords_ = "";
  public bool HasKeywords {
    get { return hasKeywords; }
  }
  public string Keywords {
    get { return keywords_; }
  }
  
  public override bool IsInitialized {
    get {
      if (!hasPage) return false;
      if (!Page.IsInitialized) return false;
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    CalcSerializedSize();
    string[] field_names = _cSGoodsFindFieldNames;
    if (hasPage) {
      output.WriteMessage(1, field_names[2], Page);
    }
    if (hasCategory) {
      output.WriteInt32(2, field_names[0], Category);
    }
    if (hasKeywords) {
      output.WriteString(4, field_names[1], Keywords);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      return CalcSerializedSize();
    }
  }
  
  private int CalcSerializedSize() {
    int size = memoizedSerializedSize;
    if (size != -1) return size;
    
    size = 0;
    if (hasPage) {
      size += pb::CodedOutputStream.ComputeMessageSize(1, Page);
    }
    if (hasCategory) {
      size += pb::CodedOutputStream.ComputeInt32Size(2, Category);
    }
    if (hasKeywords) {
      size += pb::CodedOutputStream.ComputeStringSize(4, Keywords);
    }
    size += UnknownFields.SerializedSize;
    memoizedSerializedSize = size;
    return size;
  }
  public static CSGoodsFind ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSGoodsFind ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSGoodsFind ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSGoodsFind ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSGoodsFind ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSGoodsFind ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static CSGoodsFind ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static CSGoodsFind ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static CSGoodsFind ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSGoodsFind ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private CSGoodsFind MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(CSGoodsFind prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<CSGoodsFind, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(CSGoodsFind cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private CSGoodsFind result;
    
    private CSGoodsFind PrepareBuilder() {
      if (resultIsReadOnly) {
        CSGoodsFind original = result;
        result = new CSGoodsFind();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override CSGoodsFind MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::CSGoodsFind.Descriptor; }
    }
    
    public override CSGoodsFind DefaultInstanceForType {
      get { return global::CSGoodsFind.DefaultInstance; }
    }
    
    public override CSGoodsFind BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is CSGoodsFind) {
        return MergeFrom((CSGoodsFind) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(CSGoodsFind other) {
      if (other == global::CSGoodsFind.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasPage) {
        MergePage(other.Page);
      }
      if (other.HasCategory) {
        Category = other.Category;
      }
      if (other.HasKeywords) {
        Keywords = other.Keywords;
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_cSGoodsFindFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _cSGoodsFindFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 10: {
            global::StructPage.Builder subBuilder = global::StructPage.CreateBuilder();
            if (result.hasPage) {
              subBuilder.MergeFrom(Page);
            }
            input.ReadMessage(subBuilder, extensionRegistry);
            Page = subBuilder.BuildPartial();
            break;
          }
          case 16: {
            result.hasCategory = input.ReadInt32(ref result.category_);
            break;
          }
          case 34: {
            result.hasKeywords = input.ReadString(ref result.keywords_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasPage {
     get { return result.hasPage; }
    }
    public global::StructPage Page {
      get { return result.Page; }
      set { SetPage(value); }
    }
    public Builder SetPage(global::StructPage value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasPage = true;
      result.page_ = value;
      return this;
    }
    public Builder SetPage(global::StructPage.Builder builderForValue) {
      pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
      PrepareBuilder();
      result.hasPage = true;
      result.page_ = builderForValue.Build();
      return this;
    }
    public Builder MergePage(global::StructPage value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      if (result.hasPage &&
          result.page_ != global::StructPage.DefaultInstance) {
          result.page_ = global::StructPage.CreateBuilder(result.page_).MergeFrom(value).BuildPartial();
      } else {
        result.page_ = value;
      }
      result.hasPage = true;
      return this;
    }
    public Builder ClearPage() {
      PrepareBuilder();
      result.hasPage = false;
      result.page_ = null;
      return this;
    }
    
    public bool HasCategory {
      get { return result.hasCategory; }
    }
    public int Category {
      get { return result.Category; }
      set { SetCategory(value); }
    }
    public Builder SetCategory(int value) {
      PrepareBuilder();
      result.hasCategory = true;
      result.category_ = value;
      return this;
    }
    public Builder ClearCategory() {
      PrepareBuilder();
      result.hasCategory = false;
      result.category_ = 0;
      return this;
    }
    
    public bool HasKeywords {
      get { return result.hasKeywords; }
    }
    public string Keywords {
      get { return result.Keywords; }
      set { SetKeywords(value); }
    }
    public Builder SetKeywords(string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasKeywords = true;
      result.keywords_ = value;
      return this;
    }
    public Builder ClearKeywords() {
      PrepareBuilder();
      result.hasKeywords = false;
      result.keywords_ = "";
      return this;
    }
  }
  static CSGoodsFind() {
    object.ReferenceEquals(global::Common.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class SCGoodsFind : pb::GeneratedMessage<SCGoodsFind, SCGoodsFind.Builder> {
  private SCGoodsFind() { }
  private static readonly SCGoodsFind defaultInstance = new SCGoodsFind().MakeReadOnly();
  private static readonly string[] _sCGoodsFindFieldNames = new string[] { "goods" };
  private static readonly uint[] _sCGoodsFindFieldTags = new uint[] { 10 };
  public static SCGoodsFind DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override SCGoodsFind DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override SCGoodsFind ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Common.internal__static_SCGoodsFind__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<SCGoodsFind, SCGoodsFind.Builder> InternalFieldAccessors {
    get { return global::Common.internal__static_SCGoodsFind__FieldAccessorTable; }
  }
  
  public const int GoodsFieldNumber = 1;
  private pbc::PopsicleList<global::StructGoods> goods_ = new pbc::PopsicleList<global::StructGoods>();
  public scg::IList<global::StructGoods> GoodsList {
    get { return goods_; }
  }
  public int GoodsCount {
    get { return goods_.Count; }
  }
  public global::StructGoods GetGoods(int index) {
    return goods_[index];
  }
  
  public override bool IsInitialized {
    get {
      foreach (global::StructGoods element in GoodsList) {
        if (!element.IsInitialized) return false;
      }
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    CalcSerializedSize();
    string[] field_names = _sCGoodsFindFieldNames;
    if (goods_.Count > 0) {
      output.WriteMessageArray(1, field_names[0], goods_);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      return CalcSerializedSize();
    }
  }
  
  private int CalcSerializedSize() {
    int size = memoizedSerializedSize;
    if (size != -1) return size;
    
    size = 0;
    foreach (global::StructGoods element in GoodsList) {
      size += pb::CodedOutputStream.ComputeMessageSize(1, element);
    }
    size += UnknownFields.SerializedSize;
    memoizedSerializedSize = size;
    return size;
  }
  public static SCGoodsFind ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static SCGoodsFind ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static SCGoodsFind ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static SCGoodsFind ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static SCGoodsFind ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static SCGoodsFind ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static SCGoodsFind ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static SCGoodsFind ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static SCGoodsFind ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static SCGoodsFind ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private SCGoodsFind MakeReadOnly() {
    goods_.MakeReadOnly();
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(SCGoodsFind prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<SCGoodsFind, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(SCGoodsFind cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private SCGoodsFind result;
    
    private SCGoodsFind PrepareBuilder() {
      if (resultIsReadOnly) {
        SCGoodsFind original = result;
        result = new SCGoodsFind();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override SCGoodsFind MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::SCGoodsFind.Descriptor; }
    }
    
    public override SCGoodsFind DefaultInstanceForType {
      get { return global::SCGoodsFind.DefaultInstance; }
    }
    
    public override SCGoodsFind BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is SCGoodsFind) {
        return MergeFrom((SCGoodsFind) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(SCGoodsFind other) {
      if (other == global::SCGoodsFind.DefaultInstance) return this;
      PrepareBuilder();
      if (other.goods_.Count != 0) {
        result.goods_.Add(other.goods_);
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_sCGoodsFindFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _sCGoodsFindFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 10: {
            input.ReadMessageArray(tag, field_name, result.goods_, global::StructGoods.DefaultInstance, extensionRegistry);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public pbc::IPopsicleList<global::StructGoods> GoodsList {
      get { return PrepareBuilder().goods_; }
    }
    public int GoodsCount {
      get { return result.GoodsCount; }
    }
    public global::StructGoods GetGoods(int index) {
      return result.GetGoods(index);
    }
    public Builder SetGoods(int index, global::StructGoods value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.goods_[index] = value;
      return this;
    }
    public Builder SetGoods(int index, global::StructGoods.Builder builderForValue) {
      pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
      PrepareBuilder();
      result.goods_[index] = builderForValue.Build();
      return this;
    }
    public Builder AddGoods(global::StructGoods value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.goods_.Add(value);
      return this;
    }
    public Builder AddGoods(global::StructGoods.Builder builderForValue) {
      pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
      PrepareBuilder();
      result.goods_.Add(builderForValue.Build());
      return this;
    }
    public Builder AddRangeGoods(scg::IEnumerable<global::StructGoods> values) {
      PrepareBuilder();
      result.goods_.Add(values);
      return this;
    }
    public Builder ClearGoods() {
      PrepareBuilder();
      result.goods_.Clear();
      return this;
    }
  }
  static SCGoodsFind() {
    object.ReferenceEquals(global::Common.Descriptor, null);
  }
}

#endregion


#endregion Designer generated code
